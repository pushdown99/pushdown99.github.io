---
layout: post
title: '정보보안기사/필기' 
author: haeyeon.hwang
tags: [visualization, chart, stock, finance, javascript]
description: >
  KISA에서 주관하는 국내 최고 공신력의 정보보안 자격증. 시스템 및 솔루션 개발, 운영 및 관리, 컨설팅 등의 전문 이론과 실무능력을 기반으로 IT 기반시설 및 정보에 대한 체계적인 보안업무 수행하는자. 그리고 그들을 뽑기 위한 자격검정시험.  [`IT wiki`](http://itwiki.kr/w/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88%EA%B8%B0%EC%82%AC)
image: /assets/img/blog/infosec.jpg
hide_image: true
---

{:.no_toc}
1. this unordered seed list will be replaced by toc as unordered list
{:toc}

## **정보보안기사/필기**

---

#### **정보보호 개요**

##### 정보보호관리의 개념 (출제빈도 1.3%) 

1) **==정보보호(Information Security)==**[^1]
  - 정보의 수집, 가공, 저장, 검색, 송신, 수신 중에 발생하는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단, 또는 그러한 수단으로 이루어지는 행위
  - **<u>기밀성, 무결성, 가용성, 인증성, 부인방지를 보장하기 위해 기술적 ∙ 물리적 ∙ 관리적 보호대책을 강구하는 것</u>**

2) **3대 목표 + 속성(서비스)**
  - **==기밀성(Confidentiality)==** : 오직 인가된 사람 ∙ 프로세스 ∙ 시스템만이 알 필요성(Need-to-know)에 근거하여 시스템에 접근할 수 있어야 한다.
  - **==무결성(Integrity)==** : 정보의 내용이 무단으로 생성 또는 변경되거나 삭제되지 않도록 보호되어야 한다.
  - **==가용성(Availability)==** : 시스템이 지체 없이 동작하고, 자원이 필요할 때 권한이 있는 사용자가 이용할 수 있어야한다.
  - **인증(Authentication)** : 통신 대상에 대한 인증, 데이터의 출처에 대한 인증
  - **부인방지(Non-repudiation)** : 전송이나 수신한 사실을 부인하지 못하도록 하는 것
  - 접근제어(Access Control)

3) **보안 공격(Security Attack)**

Attack|Passive/Active|Threatening
---|---|---
Snooping<br>트래픽 분석(Traffic Analysis)|Passive(소극적 공격)|Confidentiality
Modification(변경)<br>Masquerading(가장)<br>Replaying(재연, 재전송)<br>Repudiation(부인)|Active(적극적 공격)|Integrity
Denial of Service|Active|Availability

4) **시점별 통제**
- **예방통제** : 사전에 위협과 취약점에 대처하는 통제
- **탐지통제** : 위협을 탐지하는 통제. 빠르게 탐지할수록 대처하기 용이
- **교정통제** : 이미 탐지된 위협이나 취약점에 대처/감소시키는 통제
- 예방 → 탐지 → 교정 순으로 적용
  
5) **주요 보안 용어**
- 자산(Asset) : 조직이 보호해야 할 대상
- 취약점(Vulnerability) : 위협의 이용대상으로 관리적, 물리적, 기술적 약점을 의미
- 위협(Threat) : 손실이나 손상의 원인이 될 가능성을 제공하는 환경의 집합
- 위험(Risk) : 공격자(위협 주체)가 취약점을 이용하여 위협이라는 행동을 통해 자산에 악영향을 미치는 결과를 가지고 올 가능성

#### **암호학**

##### **암호학 개요** (출제빈도 2.1%)

1) **암호화와 복호화**
- 평문(Message, Plain-text) : M, P
- 암호문(Cypher-text) : C
- 암호화(Encryption) 알고리즘 : E
- 복호화(Decryption) 알고리즘 : D
- 키(Key) : K

- 암호화, 복호화의 기호적 표현
  * 암호화 : $$C = E(K,P) / C = 𝐸_𝑘(P) $$
  * 복호화 : $$P = D(K,C) / P = 𝐷_𝑘(C) $$

2) **치환 암호와 전치 암호**
- 치환 암호(대치 암호, Substitution Cipher) : 평문의 문자를 다른 문자로 <u>교환(대체)</u>하는 암호기법
- 전치 암호(Transposition) : 문자 집합 내부에서 자리를 바꾸는(<u>재배열</u>) 암호기법. 평문의 문자 집합과 암호문의 문자 집합이 일대일 대응 규칙을 갖는다.

3) **블록 암호와 스트림 암호**
- 블록 암호(Block Cipher) : 평문을 특정 비트의 블록으로 잘라낸 후 암호화 알고리즘을 적용하여 암호화. ex) DES, AES
- 스트림 암호(Stream Cipher)
  * 데이터 흐름(스트림)을 순차적으로 처리해가는 암호 알고리즘. ex) LFSR
  * 데이터 흐름을 순차적으로 처리하기 때문에 내부 상태를 가지고 있다.
  * 긴 주기와 높은 선형 복잡도가 요구된다.
  * 속도는 블록 암호화 방식보다 빠르지만 암호화 강도가 약하므로 이동 통신 등의 무선 데이터 보호에 적합.

4) **위치에 따른 암호화 구분**
- 링크 암호화(Link Encryption) : 통신 링크 양쪽 끝단에 암호화 장치를 놓는 것. 대형 네트워크에서 사용하면 필요한 암호화 장치 수가 많아지고, 중간 노드에서 데이터가 평문으로 노출된다는 단점이 있다.
- 종단간 암호화(End-to-End Encryption) : 두 종단 시스템에서 수행됨. 트래픽 분석에는 취약하지만 링크 암호화 방식보다 높은 수준의 보안 서비스를 제공한다.

5) **주요 암호 기술**
- 대칭키 암호와 비대칭키 암호
  * 대칭키 암호(Symmetric Cryptography) : ’암호화키 = 복호화키‘인 암호 알고리즘 방식
  * 비대칭키 암호(Asymmetric Cryptography) : ’암호화키 ≠ 복호화키’인 암호 알고리즘 방식
- 하이브리드 암호 시스템 : 대칭키 암호 + 비대칭키 암호
- 일방향 해시함수(one-way hash function)
- 메시지 인증 코드(MAC, Message Authentication Code) : 무결성과 인증을 제공
- 전자서명 : 무결성을 확인하고, 인증과 부인방지를 제공
- 의사난수 생성기(PRNG, Pseudo Random Number Generator) : 키 생성의 역할

6) **==암호 분석(암호 해독) 분류==**
- **<u>암호문 단독 공격</u>**(COA, Cipher-text Only Attack) : 암호문 C만을 갖고 평문 P나 키 K를 찾아내는 방법.
- **<u>기지 평문 공격</u>**(KPA, Known Plain-text Attack) : 일정량의 평문 P에 대응하는 암호문 C를 알고 있는 상태에서 해독하는 방법. 암호문 C와 평문 P의 관계로부터 키 K나 평문 P를 추정하여 해독하는 방법
- **<u>선택 평문 공격</u>**(CPA, Chosen Plain-text Attack) : 송신자(암호기)에 접근이 가능하여 평문 P를 선택하면 그 평문 P에 대한 암호문 C를 얻어내 해독하는 방법.
- **<u>선택 암호문 공격</u>**(CCA, Chosen Cypher-text Attack) : 수신자(복호기)에 접근이 가능하여 암호문 C를 선택하면 그 암호문 C에 대한 평문 P를 얻어내 암호를 해독하는 방법
- COA → KPA → CPA, CCA 순서로 공격자의 능력이 향상. 따라서 높은 단계의 공격자에게 안전한 암호 방식을 설계하는 것이 일반적인 암호 설계 방향이다.

7) **암호 알고리즘의 안정성 평가**
- CC(Common Criteria) : 정보보호시스템에 대한 공통 평가 기준
- CMVP(Cryptographic Module Validation Program) : 미국 NIST와 캐나다 CSE가 개발한 암호 모듈의 안전성 검증을 위한 프로그램. 암호기술의 구현 적합성 평가, 암호키 운용 및 관리, 물리적 보안으로 크게 나뉘어 평가를 수행

8) **==디지털 저작권 관리==**
- 스테가노그래피(Steganography) : 메시지 내용이 아닌 메시지 자체를 은폐하는 기법
- 워터마크(Watermark) : 원본의 내용을 왜곡하지 않는 선에서 저작권 정보를 디지털 콘텐츠에 삽입하는 기법
  * 강한(강성) 워터마킹 : 공격을 받아도 쉽게 파괴되거나 손상을 입지 않음
  * 약한(연성) 워터마킹 : 공격을 받으면 쉽게 파괴되거나 손상을 입음
- **핑거프린팅(Fingerprinting)**
  * 디지털 콘텐츠를 구매할 때 구매자의 정보를 삽입하는 기법
  * 불법 배포 발견 시 최초의 배포자를 추적하기 위한 기술
- **디지털 저작권 관리(DRM, Digital Rights Management)**
  * 디지털 콘텐츠 소유자가 자신의 콘텐츠에 대한 접근을 자신 또는 자신의 위임자가 지정하는 다양한 방식으로 제어할 수 있게 하는 기술적인 방법
  * 구성 요소
  
  구성요소|내용
  ---|---
  1 메타데이터(Metadata)|콘텐츠 생명주기 범위 내에서 관리되어야 할 각종 데이터의 구조 및 정보
  2 패키저(Packager)|보호 대상인 콘텐츠를 메타데이터와 함께 Secure Container 포맷으로 패키징 하는 모듈
  3 시큐어 컨테이너(Secure Container)|DRM의 보호 범위 내에서 유통되는 콘텐츠의 배포 단위
  4 식별자(Identifier)|콘텐츠를 식별하기 위한 식별자
  5 DRM 제어기(DRM Controller)|콘텐츠를 이용하는 사용자의 PC 또는 디바이스 플랫폼에서 콘텐츠가 라이선스에 명시된 범위 내에서 지속적으로 보호될 수 있도록 프로세스를 제어
   
  * DRM이 적용된 기술
    - PKI 기반의 불법복제 방지 기술 : 콘텐츠를 소비자의 암호화 키를 이용하여 패키징 함으로써 이를 다른 사람들이 이용할 수 없도록 하는 방식. 콘텐츠 배포 서버의 부담이 크다는 단점이 있어 디지털 콘텐츠 유통에 적합하지 않음
    - DOI(Digital Object Identifier) 기반의 저작권 보호 기술 : 저작권 관리 정보를 바탕으로 저작권 인증을 부여하는 기술. 불법복제 및 불법사용 방지 기능이 제공되지 않아 적극적인 저작권 보호가 불가능

##### **대칭키 암호** (출제빈도 3.3%)
- 대칭키 암호 = 관용 암호 = 공통키 암호 = 비밀키 암호

1) **==블록 암호==**
- 확산과 혼돈
   * Shannon이 정의한 개념
   * **확산(diffusion)** : 암호문 C와 평문 P 사이의 관계를 숨기는 것. C ↔ P
   * **혼돈(confusion)** : 암호문 C와 키 K의 관계를 숨기는 것. C ↔ K
- P-box (전치 장치, Permutation box) ← 확산 제공
   * 단순 P-box : n 비트를 입력 받아 n 비트를 출력, 유일하게 역함수가 존재
   * 축소 P-box : n 비트를 입력 받아 m 비트를 출력 (n > m)
   * 확장 P-box : n 비트를 입력 받아 m 비트를 출력 (n < m)
- S-box (치환 장치, Substitution box) ← 혼돈 제공
   * 역함수가 존재하는 S-box : 입력 비트 = 출력 비트
   * 역함수가 존재하지 않는 S-box : 입력 비트 ≠ 출력 비트
- **Feistel 암호 구조**
   * 암호 강도를 결정짓는 요소 : 평문 M 의 길이, 키 K의 길이, 라운드의 수
   * 암호화 과정 = 복호화 과정
  
  ![](/assets/img/blog/crypto_feistel_cipher_encryption_diagram.png)

- **SPN 암호 구조**
  * Substitution-Permutation Network
  * S-box, P-box 반복적으로 사용하는 구조

2) **블록암호에 대한 공격**
- 차분 분석 : 평문의 한 비트를 변경하면 암호문은 전혀 다른 비트 패턴으로 변화하므로, 이 변화 형태를 분석하는 공격
- 선형 분석 : 평문 비트와 암호문 비트를 일부 XOR하는 과정으로 근사적 선형 관계를 찾는 방법.
- 전수 공격 : 가능한 모든 경우에 대해 공격하는 방법. 경우의 수가 적은 경우 효율적인 방법
- 통계적 분석 : 통계적인 자료를 통해 해독하는 방법
- 수학적 분석 : 통계적 분석을 포함하여 수학적 이론을 이용하여 해독하는 방법

3) **스트림 암호**
- 동기식 스트림 암호
    * 키 스트림은 평문 or 암호문 스트림과 독립적이다.
    * 암호화, 복호화에서 상호 동기화가 필수적이며, 전송도중 변조되어도 후속 암호문에 오류의 영향이 없다.
    * One-Time Pad
      - 암호화를 수행할 때마다 랜덤하게 선택된 키 스트림을 사용
      - 이론적으로 해독이 불가능하다는 것이 Shannon에 의해 증명됨.
    * 귀환 시프트 레지스터 (Feedback Shift Register, FSR)
    * 선형 귀환 시프트 레지스터 (Linear Feedback Shift Register, LFSR) : 많은 스트림 암호가 이를 이용하며, 선형성 때문에 공격에 취약
    * 비선형 귀환 시프트 레지스터 (Non-Linear Feedback Shift Register, NLFSR)
- 비동기식(자기 동기식) 스트림 암호
    * 키 스트림은 평문 or 암호문 스트림에 종속적이다.
    * 암호문이 전송도중 변경되어도 자기 동기화가 가능
    * 변조된 암호문이 후속 암호문 복호화에 사용되지 않아 후속 암호문에 오류의 영향이 없다.

4) **==DES(Data Encryption Standard)==**
- **평문 = 64bits / 키 = 56bit** (오류검출비트 8bit 제외) / **라운드 횟수 = 16회**
- 두 개의 P-box와 16개의 Feistel 라운드 함수로 구성
- 키 생성기에 의해 <u>48bit의 라운드 키</u>가 생성
- DES 구조
  ![](/assets/img/blog/250px-DES-main-network.png)

- DES 함수 : 확장 P-box → 라운드 키와 XOR 연산 → 8개의 S-box → 단순 P-box로 구성되어 있다.
- S-Box는 비선형 함수이며, 혼돈을 제공
  ![](/assets/img/blog/des_round_function.jpg)

- DES의 취약점 : 56bits의 작은 키

5) **3DES(3중 DES)**
- H/W에서 효율적이지만 S/W에서 비효율적
- 처리 속도가 느리다.
- 두 개의 키를 갖는 3DES
  * 암호화 - 복호화 - 암호화 과정을 거쳐서 암호문이 만들어진다.
- 세 개의 키를 갖는 3DES
  * 두 개의 키를 갖는 3DES에 대한 기지평문공격(KPA) 가능성 때문에 사용
- 3DES에서 모든 키를 동일하게 하면, 보통의 DES가 된다.

6) **==AES(Advanced Encryption Standard)==**
- NIST(미국 국립기술표준원)에서 공모한 암호 알고리즘으로, **라인달(Rijndael)**이 채택되었다.
- **non-Feistel 알고리즘, SPN 구조**.
- 키의 길이에 따라 라운드가 바뀐다.

  Size|128bits|192bits|256bits 
  ---|:---:|:---:|:---:
  Round|10|12|14

- AES 단계
  * 평문을 byte 단위로 나눔
  * SubBytes (바이트 치환) : 바이트 단위로 치환
  * ShiftRows (행의 이동) : 행 단위로 순환 시프트 수행
  * MixColums (열의 혼합) : 열 단위로 혼합(Mixing). 높은 확산을 제공. 마지막 라운드에서 수행 X
  * AddRoundKey : 라운드 키와 XOR 연산
7) **==기타 대칭키 암호 알고리즘==**
- IDEA (International Data Encryption Algorithm)
  * DES를 대체하기 위한 알고리즘
  * **K = 128bits, M = 64bits**, 블록암호 구조
  * 8라운드. 마지막에 한 번 더 키를 적용시킴.
  * DES보다 안전하며, PGP(Pretty Good Privacy)의 암호 알고리즘으로 사용되고 있다.
- RC5
  * 미국에서 개발, RSA의 Rivest가 개발. (**Feistel 구조**)
  * 비교적 간단한 연산으로 빠른 암호화와 복호화 기능을 제공.
  * 모든 H/W에 적합
- Skipjack
  * 음성을 암호화하는데 주로 사용
- SEED
  * 한국에서 개발된 암호 알고리즘 (Feistel 구조)
  * **K = 128bits, M = 128bits, Round = 16**
  * 2009년에 키가 256bits로 확장되어 더 강력한 암호화 기능 제공 (SEED-256)
- ARIA
  * NSRI(국가보안기술연구소, 한국) 주도로 개발된 알고리즘 (SPN 구조)
  * **K = 128/192/256bits, M = 128bits**
- HIGHT
  * 저전력, 경량화를 요구하는 컴퓨팅 환경에서 기밀성을 제공하기 위해 개발된 알고리즘
  * **M = 64bits**
- LEA
  * 128bits 경량 고속 블록 암호 알고리즘
  * 다양한 정보보호 서비스에서 대용량 데이터를 빠르게 처리하거나 스마트폰 보안, 사물 인터넷(IoT) 등 저전력 암호화에 사용 가능  

- **Feistel 구조와 SPN 구조 알고리즘 분류**
  
  구조|알고리즘
  ---|---
  Feistel 구조|DES, RC5, SEED, LOKI, CAST, Blowfish, MISTY, Twofish, Mars 등
  SPN 구조|Rijndael(AES), ARIA, CRYPTON. SAFER, SHARK, Square 등

8) **==블록암호 사용 방식==**

  이름|특징|암호모드
  ---|---|---
  **ECB모드**<br>(Electric CodeBook)|- 가장 간단하고 빠르며, 병렬 처리 가능<br>- 평문 M의 크기가 블록 크기의 배수가 아니라면, padding이 필요.<br>$$𝑀_𝐴= 𝑀_𝐵 이면 𝐶_𝐴= 𝐶_𝐵 이다.$$|블록암호<br>(권장X)
  **CBC모드**<br>(Cipher Block Chaining)|- 복호화 시 병렬처리가 가능하지만 암호화 시에는 병렬처리 불가능<br>- 첫 번째 평문 블록 암호화시 이전 암호문이 없으므로, 초기 벡터(IV, Initialization Vector)가 사용된다.<br>- 암호화 할 때 하나의 평문 에러 발생 시, 이후의 모든 암호문에 에러가 발생한다.<br>- 복호화 할 때 하나의 암호문 에러 발생 시, 두 개의 평문에 에러가 발생한다.|블록암호<br>(Practice Crypto-graphy 권장)
  **CFB모드**<br>(Cipher FeedBack)|- 어떤 블록 암호도 스트림 암호(비동기식)로 바꿀 수 있다. → padding이 필요 없다.<br>- 복호화 시에도 암호화 함수 사용.<br>- 암호화, 복호화 시 블록 암호의 암호화 함수를 이용|스트림암호<br>(비동기식)
  **OFB모드**<br>(Output Feedback)|- 암호문 C에서 비트 손실이 발생하면 그 다음에 오는 평문은 모두 에러가 발생하기 때문에 동기를 새로 맞추어야 한다.<br>- IV가 바뀌면 암호문이 모두 바뀜<br>- 잡음이 있는 채널상의 스트림암호에 많이 사용한다.<br>- 복호화 시에도 암호화 함수 사용.|스트림암호<br>(동기식)
  **CTR모드**<br>(CounTeR)|- ECB모드처럼 독립적으로 암호화/복호화를 수행한다.<br>- 복호화 시에도 암호화 함수 사용.<br>- ATM 보안, IPsec 보안에 사용|스트림암호<br>(Practice Crypto-graphy 권장)

  ![](/assets/img/blog/cipher-block.png)

##### **비대칭키 암호** (출제빈도 3.6%)

1) **==대칭키 암호의 키 배송 문제 해결 방법=**
- 키 사전 공유
  * 키 관리기관(Trusted Authority, TA)이 사전에 사용자들에게 비밀 경로를 통하여 키를 전달
  * 많은 키가 필요. (각 사용자별로 n-1개, TA는 𝑛(𝑛−1)2 개)
- 온라인 키 분배
  * 암호 통신이 필요할 때마다 키 배포 센터(Key Distribution Center, KDC = TA)에서 키를 전달
  * KDC에서 통신하는 사용자의 키로 세션키 K를 암호화해서 전달. 각 사용자는 자신의 키로 복호화해서 세션키 K를 얻어 메시지/암호문을 암호화/복호화한다.
  * 암호 통신이 끝난 후, 사용한 세션키 K를 삭제
  * KDC는 n개의 키, 각 사용자들은 자신의 키 1개만 가진다.
- **Diffie-Hellman 키 교환**
  * 유한체상의 **이산대수 문제**(Discrete Logarithm Problem, DLP)를 풀기 어렵다는 사실에 기반
  * **키 교환(계산) 절차** (송신자:A/수신자:B)
    - A와 B는 매우 큰 소수 p와 q를 선택한다. (p, q : 공개 / x, y : 비밀 / 𝑅1 ,𝑅2 은 노출돼도 상관없음)
    - A는 임의의 큰 수 x를 0 ≤ x ≤ p−1 범위 내에서 선택하고, 𝑅1=𝑞𝑥 mod p 를 계산.
    - B는 임의의 큰 수 y를 0 ≤ y ≤ p−1 범위 내에서 선택하고, 𝑅2=𝑞𝑦 mod p 를 계산.
    - A와 B는 서로에게 𝑅1 , 𝑅2를 전달한다.
    - A는 K = (𝑅2)𝑥 mod p 를 계산해서 K를 얻는다.
    - B는 K = (𝑅1)𝑦 mod p 를 계산해서 K를 얻는다.
  * 공격 기법
    - 이산대수 공격 : 𝑅1 ,𝑅2 를 도청자가 가로채 x, y를 구하게 되면 K를 알아 낼 수 있다.
    - 중간자 공격(Man-In-The-Middle Attack, MITM) : 인증단계가 없어서 이 공격에 취약.
      = 전자서명과 공개키 인증서를 이용해서 막을 수 있다.
      = 국-대-국(STS, Station-To-Station) 프로토콜 : DH에 기반. 세션키를 만들기 위해 공개키 인증서를 이용한 전자서명을 사용하여 MITM 공격을 방지
    - DoS 공격 : DH의 계산이 복잡한 것을 이용하여 공격 대상 서버에 IP 스푸핑 등을 통해 위조한 키 생성 요청을 동시에 다수 요청하여 키 생성 시간으로 인해 서버를 마비시키는 공격
      = 키 생성 요청자를 확인하기 위한 쿠키(cookie)를 사용함으로써 방지
- 공개키 암호사용으로 해결

2) **공개키 암호**
- **대칭키** 암호 : <u>평문을 복잡한 형태로 변환</u>하여 기밀성 유지
- **공개키** 암호 : <u>수학적으로 해결하기 곤란한 문제를 기반</u>으로 기밀성 유지
- 대칭키 암호 vs 공개키 암호에서 어떤 것이 더 안전하다고 말할 수 없다.
- 공개키 암호에서는 암호화키와 복호화키가 분리되어 있다.
- 두 개의 키는 서로 수학적 관계이기 때문에 각각 별개로 만들 수 없다.

3) **RSA**(<u>R</u>ivest-<u>S</u>hamir-<u>A</u>dleman) 암호시스템
- 공개키 암호 알고리즘, 세계적으로 널리 인정되는 표준이다.
- **인수분해 문제(Prime factorization)에 근거**.
- <u>암호화</u>뿐만 아니라 <u>전자서명의 용도</u>로 사용된다.
- 암호화/복호화
  * e : 공개 / d : 비밀
  * 암호화 : **$$C = M^𝑒 mod(n)$$**
  * 복호화 : **$$M = C^𝑑 mod(n)$$**

- **키 생성 알고리즘** (공개 : e,n / 비밀 : p, q, d,Φ(n))
  1. 서로 다른 소수 p와 q를 선택
  2. N = p × q 계산
  3. Φ(N)=(p−1)(q−1) 계산
  4. Φ(N) 보다 작고, Φ(N)과 서로소인 정수 e를 찾는다.
  5. de ≡ 1 (mod Φ(N)) 을 만족하는 정수 d를 구한다.
  → 공개키 : (e, n) / 비밀키 : (d, n)

- p, q, e, d 조건
  * p와 q는 거의 같은 크기이고 최소 512bits가 되어야 한다. -> N은 최소 1024bits
  * p−1과 q−1은 큰 소인수를 갖는다.
  * p−1과 q−1의 최대공약수는 작은 수이다.
  * d와 n은 거의 같은 크기이다.
- RSA 알고리즘의 안정성은 p와 q를 구해 내는 것에 달려있다.
- 최적 비대칭키 암호 패딩 (OAEP, Optimal Asymmetric Encryption Padding)
  * RSA에서 짧은 메시지는 짧은 메시지 공격에 의해 암호문을 위험에 빠뜨리게 된다.
  * 의미 없는 padding을 메시지에 붙여 공격 작업을 어렵게 한다.
- 공격 기법
  * 수학적 공격(소인수 분해 공격) : 두 개의 소수 곱을 인수분해 하려는 시도
  * 타이밍 공격(시간 공격) : 복호화 알고리즘 실행 시간에 의존
  * 선택 암호문 공격(CCA) : 임의의 데이터 송신 시 그것을 암호문으로 간주하고 회신해주는 것을 이용한 공격. OAEP로 방지할 수 있다.

4) **Rabin 암호시스템**
- 합성수 모듈러에 관하여 제곱근을 찾기 어렵다는 사실로부터 안정성을 얻는다. (인수분해 문제)
- 암호화 과정은 오직 한 번의 곱셈으로 매우 빨리 수행된다.
- Rabin 암호시스템의 복잡도는 큰 수 n을 두 개의 소수의 곱으로 소인수분해하는 수준의 복잡도와 같다.
- p와 q의 크기가 충분히 크다면 RSA만큼 안전하다.

5) **ElGamal 암호시스템**
- **이산대수 문제**에 근거.
- 암호화과정에서 암호문의 길이는 평문의 약 2배가 됨.
- 때문에, 많은 메모리 공간이 필요, 전송 속도도 느려짐.

6) **타원 곡선 암호(ECC, Elliptic Curve Cryptosystem)**
- 타원 곡선(Elliptic Curve)이라는 이론에 근거 (타원곡선 군에서의 이산대수 문제)
- **RSA보다 키의 길이를 줄이면서도 동일한 성능을 제공**하여 전자상거래의 핵심 기술로 주목받고 있음
- H/W와 S/W로 구현하기가 용이
- 메모리와 처리능력이 제한된 응용분야(스마트카드, 무선통신 단말기 등)에 효율적  

7) **하이브리드 암호시스템**
- 대칭키 암호의 기밀성 + 공개키 암호로 키 배송 문제 해결
- 공개키 암호 문제점 2가지
  * 대칭키 암호에 비해 처리속도가 많이 느리다. → 하이브리드 암호시스템
  * MITM 공격에 약하다. → 공개키에 대한 ‘인증’이 필요

8) ==**인수분해/이산대수 근거 암호시스템 분류**==
- 인수분해 문제 : RSA, Rabin
- 이산대수 문제 : Diffie-Hellman, ElGamal, ECC, DSS

##### **해시함수와 응용** (출제빈도 1.6%) 

1) **==일방향 해시함수==**
- 해시함수 : 임의의 길이 m을 갖는 메시지 M을 입력으로 해서 고정된 길이 n을 갖는 해시 값 또는 해시 코드라 불리는 값을 출력하는 함수
- 충돌이 존재. 해시 값 한 개에 여러 메시지를 가질 수 있다.
- 일방향 해시함수 = 메시지 다이제스트 함수 = 암호학적 해시 함수
- 출력되는 해시 값 = 메시지 다이제스트 = 핑거프린트
- **특징**
  * 임의 길이의 메시지로부터 고정 길이의 해시 값을 계산
  * 해시 값을 고속으로 계산할 수 있다.
  * 일방향성을 갖는다. : 해시 값으로부터 메시지를 구할 수 없다.
  * 메시지가 다르면 해시 값도 다르다.
- 충돌을 발견하는 것이 어려운 성질을 **충돌 내성(collision resistance)**이라고 부른다.
- 랜덤 오라클 모델(Random Oracle Model)
  * 해시함수에 대한 이상적인 수학적 모델
  * 임의의 길이를 갖는 메시지에 오라클은 난수로 생성된 고정된 길이의 메시지 다이제스트를 생성, 제공
  * 이미 다이제스트가 존재하는 메시지가 주어지면 오라클은 저장되어 있던 다이제스트 제공
  * 새로운 메시지에 대해서는 이미 생성한 다이제스트와는 다른 다이제스트를 생성
- 공격 기법
  * 무차별 공격 : 약한 충돌 내성을 깨고자 하는 공격
  * 일치블록 연쇄공격 : 사전에 해시 값을 다양하게 생성 후 공격하고자 하는 메시지의 해시 값과 같은 것을 찾는 공격
  * 중간자 연쇄공격 : 전체 해시 값이 아닌 해시 중간 결과에 대한 충돌 쌍을 찾는다.
  * 고정점 연쇄공격 : 메시지 블록과 연쇄변수 쌍을 얻어 연쇄변수가 발생하는 특정한 점에 임의의 동등한 블록들을 메시지 중간에 삽입해도 전체 해시 값이 변하지 않는다.
  * 차분 연쇄공격 : 압축함수의 입출력 차이를 조사하여 0의 충돌쌍을 찾아내는 공격

2) **==해시함수의 보안 요구사항==**
- **역상 저항성 (= 약 일방향성)**
  * y = h(M)을 만족하는 <u>입력 값 M</u>을 찾는 것이 매우 힘들어야 된다.
  * 안전성, 역함수 계산 방지
- **두 번째 역상 저항성 (= 약한 충돌 내성 = 강 일방향성)**
  * y = h(M) = h(M′), M ≠ M′ 을 만족하는 <u>다른 입력 값 M′</u>을 찾는 것이 매우 힘들어야 한다.
  * 안전성, 역함수 계산 방지
- **충돌 저항성 (= 강한 충돌 내성 = 충돌 회피성)**
  * y = h(M) = h(M′)을 만족하는 <u>임의의 두 입력 값 M, M′</u>을 찾는 것이 매우 힘들어야 한다.
  * 안전성, 내부부정 방지
  * 충돌 저항성은 두 번째 역상 저항성을 보장

3) **키가 없는 해시함수**
- 메시지 다이제스트(Message Digest)
  * MD2 → MD4 → MD5
  * MD5는 메시지를 <u>512bits로 된 블록</u>으로 나누고 <u>128bits 다이제스트를 출력</u>한다. <u>라운드 수는 64(14 * 4R)</u>
  * 128bits 메시지 다이제스트는 충돌 공격에 내성을 갖기에는 길이가 너무 짧다고 알려진다.
  * 내부 구조에 대한 약점이 발견되고, 생일 공격에 노출되었다.
- SHA(Secure Hash Algorithm)
  * MD4 해시함수에 기초해서 만들어짐. MD5보다 느리지만 조금 더 안전.
  * SHA-160 (SHA-1) : 메시지를 <u>512bits 블록</u>으로 나누고 <u>160bits의 다이제스트를 출력</u>한다. <u>라운드 수는 80(20 * 4R)</u>
  * SHA-512 (SHA-2) : 메시지를 <u>1024bits 블록</u>으로 나누고 <u>512bits의 다이제스트를 출력</u>한다. 메시지의 길이는 2128bits를 넘지 않는다.
- RIPEMD-160 : 메시지를 512bits 블록으로 나누고 160bits의 다이제스트를 출력한다.
- Tiger : 64bits 시스템에서 해시 함수를 수행하기 위해 설계. MD5, SHA-1보다 속도가 빠르다.
- HAVAL : 메시지를 1024bits 블록으로 나누고 128/160/192/224/256bits의 다이제스트를 출력한다.
- HAS160 : 메시지를 512bits 블록으로 나누고 160bits의 다이제스트를 출력. 한국형 전자서명 표준에 사용할 목적으로 개발됨.
- 변경 감지 코드(MDC, Modification Detection Code)
  * 메시지의 무결성을 보장하는 메시지 다이제스트
  * 수신자는 메시지로부터 새로운 MDC를 생성하고, 송신자에게 받은 MDC와 비교하여 해당 메시지가 변경되지 않았다는 것을 보장해준다.

4) **==키를 사용하는 해시함수, MAC==**
- <u>무결성을 확인</u>하고, 메시지에 대한 인증을 하는 기술
- 대칭키 암호 사용. (MAC 알고리즘으로 블록 암호나 해시 함수에 기반을 둠)
- **대칭키 암호를 사용**함으로써, 키 배송 문제가 생긴다.
- 축소 MAC : 해시 과정이 두 단계로 이루어져 있음. (키도 두 번 사용)
- **HMAC** : 앞의 H는 해시함수를 의미하며, SHA-1과 같은 일방향 해시함수를 이용하여 MAC를 구성
- CBC-MAC : 블록 암호 모드인 CBC모드와 유사한 방법
- CMAC : CBC-MAC와 같은 종류의 데이터 인증과 무결성을 제공하지만, 조금 더 안전
- CCM(Counter with CBC-MAC) : CTR 모드와 CBC-MAC을 통합. AES 암호 알고리즘, CTR 모드, CBC-MAC 인증 알고리즘으로 구성
- GCM mode : CTR 모드에 인증 기능을 추가한 모드
- 재전송 공격
  * MAC 값을 도청해서 저장해둔 뒤 저장해둔 MAC 값을 반복해서 송신하는 공격
  * 보안 대책으로 순서 번호, 타임스탬프, 비표(nonce), 시도/응답이 있다.
- **MAC가 해결하지 못하는 문제**
  * 제 3자에 대한 증명 : 두 사람 사이에서는 상대방이 MAC를 계산하였다고 말할 수 있지만, 제 3자에게 MAC 값을 누가 계산했는지 증명할 방법이 없다. → 전자서명으로 증명 가능
  * 부인 방지 → 역시 전자서명으로 부인 방지가 가능해진다.

##### **전자서명과 PKI** (출제빈도 4.0% / 매회 2~4문제 출제)

1) **전자서명 서비스**
- 전자서명의 형식
  * 공개키 암호방식을 이용한 공개키 서명 방식 : 누구나 검증 가능하여, 서명 생성 및 검증이 간편
  * 관용 암호방식을 이용한 중재 서명 방식 : 서명 생성과 검증을 제3자가 중재. 서명할 때마다 제3자의 참여가 있어야 함.
- **메시지 인증** : 수신자 B는 받은 메시지가 송신자 A로부터 왔다는 것을 알 수 있다.
- **메시지 무결성** : 메시지가 변경되면 서명도 변경된다. (해시함수, 공개키)
- **부인방지** : 신뢰받는 제 3자로부터 검증받을 수 있다.
- 공개키 알고리즘을 사용하면 기밀성을 보장할 수 있다.
- 암호화 시스템에서는 수신자의 개인키와 공개키가 사용되고, 전자서명에서는 송신자의 개인키와 공개키가 사용된다.
- **<u>전자서명의 주요기능</u>** : 위조 불가, 서명자 인증, 부인방지, 변경 불가, 재사용 불가
  * 위조 불가 : 합법적인 서명자만이 전자서명을 생성할 수 있어야 한다.
  * 서명자 인증 : 전자서명의 서명자를 누구든지 검증할 수 있어야 한다.
  * 부인방지 : 서명자는 서명행위 이후에 서명한 사실을 부인할 수 없어야 한다.
  * 변경 불가 : 서명한 문서의 내용을 변경할 수 없어야 한다.
  * 재사용 불가 : 전자문서의 서명을 다른 전자문서의 서명으로 사용할 수 없어야 한다.
  
2) **전자서명 구조**
- RSA 전자서명 구조
  * 전자서명 구조에서는 개인키와 공개키의 역할이 바뀐다.
  * 암호화에서는 수신자의 키를 이용했지만, 전자서명에서는 송신자의 개인키와 공개키를 이용한다.
- ElGamal 전자서명 구조 : ElGamal 암호시스템과 동일한 키를 사용하지만 알고리즘은 다르다.
- Schnorr 전자서명 구조 : ElGamal 기반이지만 서명의 크기를 줄인 새로운 구조
- DSS(Digital Signature Standard)
  * ElGamal 전자서명을 개량한 방식. (이산대수 문제)
  * 오직 전자서명 기능만을 제공하도록 설계되었고 서명과 검증에 소요되는 계산량을 줄임.
- 타원곡선 전자서명 구조(ECDSA, Elliptic Curve DSA) : 짧은 비트 길이로 인해 짧은 처리 시간에 짧은 서명 생성이 가능

3) **전자서명 방식**
- 복원형 전자서명
  * 기존 공개키 암호방식을 이용하여 별도의 전자서명 프로토콜이 필요 없음.
  * 메시지를 일정 크기 블록으로 나누어, 그 각각의 블록에 서명을 해야 하므로 시간 소요↑
  * 실제로는 사용되지 않는다.
- **부가형 전자서명**
  * 메시지를 해시하여 나온 다이제스트에 <u>한 번의 서명 생성 과정</u>만이 필요하므로 효율적이다.
  * 전송량이 조금 늘어나지만 실제로 많이 사용되는 방법이다.

4) **특수 전자서명**
- 공개키 방식을 이용한 전자 서명은 검증하는 키가 공개되어 있어서 서명의 검증을 누구나 할 수 있는 문제점이 있다.
- 부인방지 전자서명 : 자체 인증 방식을 배제시키고 서명 검증할 때, 서명자의 도움이 있어야 검증이 가능한 방식
- 의뢰 부인방지 서명 : 신뢰하는 제 3자가 서명을 검증해주는 방식
- 수신자 지정 서명 : 지정한 검증자만이 서명을 검증할 수 있고, 필요시 제 3자에게 그 서명이 서명자에 의해 자신에게 발행된 서명임을 증명할 수 있게 하는 방식
- 위임 서명 : 부재 중 자신을 대리해서 서명을 할 수 있는 방식.
- **은닉 서명(Blind Digital Signature)** : 서명문의 내용을 숨기는 방식. 익명성을 유지할 수 있음.
- 다중 서명 : 동일 전자문서에 여러 명이 서명하는 방식

5) 전자투표 시스템
- 요구사항
  * 완전성 : 투표 결과의 정확한 집계
  * 익명성 : 투표 결과로부터 투표자 구별 불가
  * 건전성(강건성) : 부정 투표자에 의한 선거 방해가 없어야 한다.
  * 이중투표방지(재사용 불가) : 정당한 투표자는 단 1회만 투표 허용
  * 정당성 : 투표에 영향을 미치는 것이 없어야 한다.
  * 적임성 : 투표권 없는 자의 투표 행위 금지
  * 검증 가능 : 투표 결과를 누구나 확인하여 검증해볼 수 있다.(투표 결과 위조 불가능)
- 방식 (PSEV - 키오스크 - REV)
  * PSEV 방식 : 기존 선거 방식 + 전자
  * 키오스크(kiosk) 방식 : PSEV 방식과 유사하지만 공공장소에 설치, 관리자 없음
  * REV 방식 : 어디서든 투표 가능. 비밀투표 침해가능성 높음

6) 전자입찰 시스템
- 요구사항
  * 독립성 : 각 구성요소는 독자적인 자율성을 보장받아야 함
  * 비밀성 : 네트워크상의 개별 정보는 누구에게도 노출되지 않아야 함
  * 무결성 : 입찰 시 입찰자 자신의 정보를 확인 가능하게 하여, 누락 및 변조 여부 확인이 가능해야 함
  * 공평성 : 입찰이 수행될 때 모든 정보는 공개되어야 함
  * 안전성 : 각 입찰 참여자 간의 공모 방지

7) 전자서명으로 해결할 수 없는 문제
- 서명 검증을 할 때 이용하는 공개키가 진짜 송신자의 공개키가 맞는지의 문제를 해결하기 위해 공개키 인증서가 고안되었다.
- 공개키 인증서는 공개키를 메시지로 간주하고 신뢰 가능한 제 3자에게 전자서명을 해서 받은 공개키이다. 이 기반 구조를 PKI(Public Key Infrastructure, 공개키 기반 구조)라고 한다.

8) PKI 개념
- 공개키 알고리즘을 위한 키 관리 구조
- 제공 서비스 : 기밀성, 무결성, 인증, 부인방지, 접근제어
- 일방향 해시함수 → MAC → 전자서명 → PKI 의 흐름으로 이어진다.

9) PKI 구성요소
- 크게 인증기관, 검증기관, 등록기관, 저장소, 사용자로 구성되어 있다.
- 인증기관(CA, Certification Authority) : 인증정책 수립, 인증서 관리, 다른 CA와의 상호 인증
  * 정책승인기관(PAA, Policy Approving Authority)
    - 루트 인증기관으로, PKI 전반에 사용되는 정책을 생성, 수립
    - 하위 기관들의 정책 감사
  * 정책인증기관(PCA, Policy Certification Authority)
    - PAA 하위 계층, 하위 CA, 사용자들의 정책 수립
    - CA의 공개키를 인증하고 인증서, 인증서 폐지 목록 등을 관리
  * 인증기관(CA)
    - PCA 하위 계층.
    - 사용자/등록기관의 요청에 공개키 인증서를 발행∙폐지
    - 사용자에게 자신의 공개키와 상위 기관의 공개키를 전달
- 검증기관(VA, Validation Authority)
  * 인증서의 유효성 여부 / 관련 거래의 유효성 여부 등을 확인시켜줌.
  * 적절한 인증서 검증 기능이 없다면, 보안성이 떨어진다.
  * CA에서 직접 운영가능.
- 등록기관(RA, Registration Authority)
  * 사용자와 CA가 원거리에 있는 경우, 사용자와 CA 사이에 RA를 두어 사용자의 인증서 신청 시 CA 대신 사용자의 신분∙소속 등을 확인
  * 선택적 요소. RA가 없으면 CA가 RA의 기능을 대신 수행할 수 있다.
  
10) PKI 형태
- 계층 구조
  * 최상위에 루트 CA가 존재하고, 그 밑으로 하위 CA가 계층적으로 존재하는 트리 구조.
  * 상위 CA가 하위 CA에 인증서를 발행하고, 하위 CA는 상위 CA의 인증정책에 영향을 받는다.
  * 루트 CA 간에 상호인증은 허용하지만, 하위 CA 간에 상호인증은 불가능.
  * 정부 같은 관료조직에 적합, 협동업무 관계에는 부적합
  * 인증경로 탐색이 용이하고, 모든 사용자가 최상위 CA의 공개키를 알고 있어서 검증이 용이
  * 최상위 CA에 집중되는 오버헤드가 발생
  * 최상위 CA의 비밀키 노출이 되면 피해가 막대하다.
- 네트워크 구조
  * 각각의 CA들이 자신의 인증정책에 따라 독립적으로 존재하는 형태
  * 모든 상호인증이 허용되면 상호인증의 수가 대폭 증가
  * 유연하고 인증경로 단순하여 실질적인 업무관계에 적합.
  * CA의 비밀키가 노출이 되도 피해가 적다.
  * 인증경로 탐색이 복잡하고, 정책 수립과 적용이 어려움  

11) 인증서 표준 규격 X.509
- 공개키 인증서 (PKC, Public Key Certificate)
  * 해당키가 특정인의 것이라는 것을 보증해주는 것
  * 개인정보, 소유자의 공개키가 들어있고, CA의 개인키로 전자서명 되어있다.
- X.509 v3 인증서 프로파일

요소|구분|설명
---|---|---
버전<br>(Version)|필수|X.509의 버전
일렬번호<br>(Serial Number)|필수|CA에 의해 인증서에 부여되는 유일한 번호. (발행자이름과 일렬번호로 인증서를 유일하게 구분할 수 있어야 한다.)
서명 알고리즘 식별자<br>(Signature Algorithm ID)|필수|CA가 인증서를 서명하기 위한 알고리즘과 알고리즘 식별자를 포함. 이 정보는 끝부분 서명 필드에도 포함되어 있다. 
발행자 이름<br>(Issuer name)|필수|인증서 발행자(보통 CA)의 이름
유효기간<br>(Validity period)|필수|인증서 유효기간의 시작날짜와 종료날짜
주체 이름<br>(Subject name)|필수|사용자(피발급자)의 이름 상위 CA가 하위 CA에게 인증서를 발행하는 경우 이 필드에는 CA의 이름이 된다.
주체의 공개키 정보<br>(Subject Public Key)|필수|사용자의 공개키, 관련 알고리즘
발행자 유일 식별자<br>(Issuer Unique ID)|선택<br>(v2)|발행자나 사용자의 이름이 중복되는 경우 이를 구별하기 위한 수단
주체 유일 식별자<br>(Subject Unique ID)|선택<br>(v2)|주체를 유일하게 구별하는 데 사용 확장 (Extensions) 선택 (v3) 발행자가 인증서에 추가적으로 사적인 정보를 넣을 수 있는 필드
서명<br>(Signature)|필수|인증서에 대한 서명 값이 들어있는 필드 나머지 전체 필드를 보호하는 역할을 한다. 다른 필드 전체를 해시해서 나온 해시 값을 CA의 개인키로 암호화한 값이 들어간다.

- X.509의 확장영역에는 키와 정책 정보, 사용자와 발행자 속성, 인증 경로 제약조건이 들어간다.
- X.509 인증서 폐지 목록
  * 인증서 폐지 목록(CRL, Certificate Revocation List)은 CA의 저장소 또는 디렉터리에 저장되어 신뢰 사용자가 언제든지 이 목록을 검색할 수 있어야 한다.
  * CRL 내의 폐기된 인증서들은 인증서 일렬번호에 의해서 확인할 수 있다.
  * 인증서 폐지 사유
    - 사용자의 개인키가 노출되었거나 훼손된 것으로 판단되는 경우
    - CA가 사용자를 더 이상 인증해줄 수 없을 경우
    - CA의 개인키가 노출되었거나 훼손된 것으로 판단되는 경우
- 온라인 인증서 상태 검증 프로토콜(OCSP, Online Certificate Status Protocol)
  * 실시간으로 인증서 상태를 확인할 수 있는 프로토콜
  * 백그라운드에서 자동으로 수행하며, CA에 의해 관리되고 있는 CRL을 검사
  * OCSP 클라이언트, OCSP 서버, 인증 서버로 구성
- 인증서 관리 프로토콜(CMP, Certificate Management Protocol) : PKI 환경에서 인증서 관리 서비스를 제공하기 위한 PKI 실체들(이용자, CA, RA 등) 간의 통신 프로토콜

##### **키, 난수** (출제빈도 0.3%)

- 세션키(Session key) : 통신 때마다 한 번만 사용되는 키
- C 마스터키(Master key) : 반복적으로 사용되는 키
- CEK(Contents Encrypting Key) : 사용자가 이용하는 콘텐츠를 암호화하는 키
- KEK(Key Encrypting Key) : 키를 암호화하는 키
- 솔트(Salt)
  * 키(KEK)를 만들 때 패스워드와 함께 일방향 해시함수에 입력된다.
  * 사전공격을 막기 위해 존재
  * KEK를 만들 때 솔트를 사용하면 KEK 후보가 솔트의 비트 길이만큼 늘어난다.
- 난수의 성질 : 무작위성 - 예측 불가능성 - 재현 불가능성
- 의사난수 생성기 : 난수(의사난수)를 생성하는 S/W

----

#### **접근통제**

##### **접근통제 개요** (출제빈도 0.7%)
- 접근제어 : 허가되지 않은 자원의 사용과 허가되지 않은 방법을 통한 자원 사용을 제어하는 것
- 주체(행위자), 접근(주체의 활동), 객체(제공자)
- 접근 통제 절차 3+1가지
  * 식별 : 본인이 누구라는 것을 시스템에 밝히는 행위(ID, 계정번호, 메모리카드)
  * 인증 : 주체의 신원을 검증하기 위한 증명(패스워드, 스마트카드, 생채인증)
  * 인가 : 인증된 주체에게 접근을 허용하고 특정 업무를 수행할 권리를 부여(접근제어목록, 보안등급)
  * 책임추적성 : 시스템에 인가된 주체가 시스템에 어떤 행위를 하고 있는지 기록
- 기본 원칙 : 직무 분리, 최소 권한 등


[^1]: 기밀성, 무결성, 가용성, 인증성, 부인방지를 보장하기 위해 기술적 ∙ 물리적 ∙ 관리적 보호대책을 강구하는 것
[^2]: 오직 인가된 사람 ∙ 프로세스 ∙ 시스템만이 알 필요성(Need-to-know)에 근거하여 시스템에 접근할 수 있어야 하는 것.
[^3]: 정보의 내용이 무단으로 생성 또는 변경되거나 삭제되지 않도록 보호되어야 함.
[^4]: 시스템이 지체 없이 동작하고, 자원이 필요할 때 권한이 있는 사용자가 이용할 수 있어야 함.
[^5]: 통신 대상에 대한 인증, 데이터의 출처에 대한 인증
[^6]: 전송이나 수신한 사실을 부인하지 못하도록 하는 것
[^7]: 위협의 이용대상으로 관리적, 물리적, 기술적 약점을 의미
[^8]: 손실이나 손상의 원인이 될 가능성을 제공하는 환경의 집합
[^9]: 공격자(위협 주체)가 취약점을 이용하여 위협이라는 행동을 통해 자산에 악영향을 미치는 결과를 가지고 올 가능성